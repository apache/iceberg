/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.iceberg.encryption;

import java.io.Serializable;
import java.util.Collection;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import org.apache.iceberg.Schema;
import org.apache.iceberg.exceptions.ValidationException;
import org.apache.iceberg.relocated.com.google.common.base.MoreObjects;
import org.apache.iceberg.relocated.com.google.common.base.Preconditions;
import org.apache.iceberg.relocated.com.google.common.collect.ImmutableSet;
import org.apache.iceberg.relocated.com.google.common.collect.Maps;
import org.apache.iceberg.relocated.com.google.common.collect.Sets;
import org.apache.iceberg.relocated.com.google.common.primitives.Ints;
import org.apache.iceberg.types.Types;

/**
 * Configuration for an envelope encryption.
 * <p>
 * There are 2 envelope encryption schemes we support:
 * <p>
 * Single wrap: a key encryption key (KEK) is stored in KMS, with ID stored in the {@link EnvelopeEncryptionSpec}.
 * For every new file, a new data encryption key (DEK) is generated by KMS via the KEK ID to encrypt the file.
 * The KEK ID and encrypted DEK are stored as {@link EncryptionKeyMetadata}.
 * <p>
 * Double wrap: a master encryption key (MEK) is stored in KMS, with ID stored in the {@link EnvelopeEncryptionSpec}.
 * A writer generates a new KEK based on certain key generation configurations,
 * such as one new KEK per writer process per hour.
 * The MEK ID, KEK ID, encrypted KEK, encrypted DEK are stored as {@link EncryptionKeyMetadata}
 * The KEK ID is leveraged by the reader to cache KEK decryption result.
 * Compared to single wrap, double wrap can significantly reduces the load to KMS,
 * with the tradeoff that more information is stored in metadata and KEK rotation becomes more complex.
 * <p>
 * The config itself is defined recursively, as each file level config can be associated with some column level configs.
 * Each file level config is expected to contain an array of column level configs.
 * Each column level config is expected to specify an array of source column IDs that shares the config.
 */
public class EnvelopeConfig implements Serializable {

  private final String mekId;
  private final String kekId;
  private final EncryptionAlgorithm algorithm;
  private final Map<String, String>  properties;

  private final int[] columnIds;
  private final EnvelopeConfig[] columnConfigs;

  private transient volatile Set<Integer> columnIdSet;
  private transient volatile Set<EnvelopeConfig> columnConfigsSet;
  private transient volatile Map<Integer, EnvelopeConfig> columnConfigsMap;

  public EnvelopeConfig(
      String mekId,
      String kekId,
      EncryptionAlgorithm algorithm,
      Map<String, String> properties,
      Collection<Integer> columnIdCollection,
      Collection<EnvelopeConfig> columnConfigCollection) {
    this.mekId = mekId;
    this.kekId = kekId;
    Preconditions.checkArgument(mekId != null || kekId != null,
        "Cannot construct envelope config because either MEK or KEK ID should be specified");
    this.algorithm = Preconditions.checkNotNull(algorithm,
        "Cannot construct envelope config because encryption algorithm must not be null");
    this.properties = properties == null ? Maps.newHashMap() : properties;
    this.columnIds = columnIdCollection == null ? null : Ints.toArray(columnIdCollection);
    this.columnConfigs = columnConfigCollection == null ? null : columnConfigCollection.toArray(new EnvelopeConfig[0]);
  }

  public String mekId() {
    return mekId;
  }

  public String kekId() {
    return kekId;
  }

  public EncryptionAlgorithm algorithm() {
    return algorithm;
  }

  /**
   * Properties defined by keys in {@link EncryptionProperties}
   * <p>
   * Users can define free-form properties that are used for features such as column data masking.
   * Properties that starts with {@link EncryptionProperties#AAD_PREFIX} is used
   * to form the additional authenticated data (AAD) that will be used during {@link KeyProvider#generateKey}
   * @return encryption properties
   */
  public Map<String, String> properties() {
    return properties;
  }

  public Map<String, String> aad() {
    return properties().entrySet().stream()
        .filter(e -> e.getKey().contains(EncryptionProperties.AAD_PREFIX))
        .collect(Collectors.toMap(
            e -> e.getKey().substring(EncryptionProperties.AAD_PREFIX.length()),
            Map.Entry::getValue));
  }

  public Set<Integer> columnIds() {
    return lazyColumnIdSet();
  }

  private Set<Integer> lazyColumnIdSet() {
    if (columnIdSet == null) {
      synchronized (this) {
        if (columnIdSet == null) {
          columnIdSet = ImmutableSet.copyOf(Ints.asList(columnIds));
        }
      }
    }

    return columnIdSet;
  }

  public Set<EnvelopeConfig> columnConfigs() {
    return lazyColumnConfigSet();
  }

  private Set<EnvelopeConfig> lazyColumnConfigSet() {
    if (columnConfigsSet == null) {
      synchronized (this) {
        if (columnConfigsSet == null) {
          columnConfigsSet = ImmutableSet.copyOf(columnConfigs);
        }
      }
    }

    return columnConfigsSet;
  }

  public Map<Integer, EnvelopeConfig> columnConfigMap() {
    return lazyColumnConfigMap();
  }

  private Map<Integer, EnvelopeConfig> lazyColumnConfigMap() {
    if (columnConfigsMap == null) {
      synchronized (this) {
        if (columnConfigsMap == null) {
          columnConfigsMap = Maps.newHashMap();
          for (EnvelopeConfig field : columnConfigs) {
            for (int columnId : field.columnIds()) {
              columnConfigsMap.put(columnId, field);
            }
          }
        }
      }
    }

    return columnConfigsMap;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }

    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    EnvelopeConfig config = (EnvelopeConfig) o;
    return Objects.equals(mekId, config.mekId) &&
        Objects.equals(kekId, config.kekId) &&
        algorithm == config.algorithm &&
        Objects.equals(properties, config.properties) &&
        Objects.equals(columnIds(), config.columnIds()) &&
        Objects.equals(columnConfigs(), config.columnConfigs());
  }

  @Override
  public int hashCode() {
    return Objects.hash(mekId, kekId, algorithm, properties, columnIds(), columnConfigs());
  }

  @Override
  public String toString() {
    return MoreObjects.toStringHelper(this)
        .add("mekId", mekId)
        .add("kekId", kekId)
        .add("algorithm", algorithm)
        .add("properties", properties)
        .add("columnIds", columnIds)
        .add("columnConfigs", columnConfigs)
        .toString();
  }

  public static Builder builderFor(Schema schema) {
    return new Builder(schema);
  }

  /**
   * A builder used to create valid {@link EnvelopeConfig}.
   * <p>
   * Call {@link #builderFor(Schema)} to create a new builder.
   */
  public static class Builder {

    private final Schema schema;

    private String mekId;
    private String kekId;
    private EncryptionAlgorithm algorithm;
    private Map<String, String>  properties = Maps.newHashMap();
    private final Set<Integer> columnIds = Sets.newHashSet();
    private final Set<EnvelopeConfig> columnConfigs = Sets.newHashSet();

    public Builder(Schema schema) {
      this.schema = schema;
    }

    public Builder singleWrap(String keyId) {
      this.kekId = keyId;
      this.mekId = null;
      return this;
    }

    public Builder doubleWrap(String keyId) {
      this.kekId = null;
      this.mekId = keyId;
      return this;
    }

    public Builder putProperty(String key, String value) {
      this.properties.put(key, value);
      return this;
    }

    public Builder removeProperty(String key) {
      this.properties.remove(key);
      return this;
    }

    public Builder useAlgorithm(EncryptionAlgorithm encryptionAlgorithm) {
      this.algorithm = encryptionAlgorithm;
      return this;
    }

    public Builder addColumnConfig(EnvelopeConfig config) {
      this.columnConfigs.add(config);
      return this;
    }

    public Builder addColumn(String name) {
      Types.NestedField column = schema.findField(name);
      ValidationException.check(column != null, "Cannot find column with name %s in schema %s", name, schema);
      columnIds.add(column.fieldId());
      return this;
    }

    public Builder addColumn(int id) {
      Types.NestedField column = schema.findField(id);
      ValidationException.check(column != null, "Cannot find column with ID %s in schema %s", id, schema);
      columnIds.add(column.fieldId());
      return this;
    }

    public EnvelopeConfig build() {
      return new EnvelopeConfig(mekId, kekId, algorithm, properties, columnIds, columnConfigs);
    }

  }

}
